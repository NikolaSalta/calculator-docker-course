/*
 * ═══════════════════════════════════════════════════════════════════════════
 * App.js — Главный компонент калькулятора
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Что такое компонент в React?
 * Компонент — это функция, которая возвращает JSX (описание UI).
 * Компоненты можно переиспользовать и комбинировать.
 *
 * Что такое JSX?
 * JSX (JavaScript XML) — расширение синтаксиса JavaScript.
 * Позволяет писать HTML-подобный код внутри JavaScript.
 * При компиляции превращается в обычные вызовы функций.
 *
 * Пример:
 *   JSX:     <div className="box">Hello</div>
 *   JS:      React.createElement('div', {className: 'box'}, 'Hello')
 * ═══════════════════════════════════════════════════════════════════════════
 */

// ─────────────────────────────────────────────────────────────────────────────
// ИМПОРТЫ
// ─────────────────────────────────────────────────────────────────────────────

/*
 * React — библиотека React
 * useState — хук для управления состоянием компонента
 *
 * Что такое хук (hook)?
 * Хук — это функция, которая позволяет использовать возможности React
 * (состояние, жизненный цикл) в функциональных компонентах.
 *
 * Правила хуков:
 * 1. Вызывать только на верхнем уровне (не в циклах, условиях)
 * 2. Вызывать только в React-компонентах или других хуках
 */
import React, { useState } from 'react';


// ─────────────────────────────────────────────────────────────────────────────
// ГЛАВНЫЙ КОМПОНЕНТ
// ─────────────────────────────────────────────────────────────────────────────

/*
 * function App() — функциональный компонент
 *
 * Почему функция, а не класс?
 * В современном React (16.8+) функциональные компоненты с хуками
 * полностью заменили классовые компоненты.
 * Они проще, короче и легче тестируются.
 */
function App() {
  
  // ═══════════════════════════════════════════════════════════════════════════
  // СОСТОЯНИЕ (STATE)
  // ═══════════════════════════════════════════════════════════════════════════
  
  /*
   * useState — хук для создания состояния
   *
   * Синтаксис: const [значение, функцияУстановки] = useState(начальноеЗначение)
   *
   * useState возвращает массив из двух элементов:
   * 1. Текущее значение состояния
   * 2. Функция для изменения состояния
   *
   * Мы используем деструктуризацию массива для получения обоих элементов:
   * const [a, setA] = useState('')
   *         │   │              │
   *         │   │              └── Начальное значение (пустая строка)
   *         │   └── Функция для изменения a
   *         └── Текущее значение
   *
   * Когда вызывается setA('новое значение'):
   * 1. React запоминает новое значение
   * 2. React перерендеривает компонент
   * 3. При следующем рендере a будет равно 'новое значение'
   */
  
  // Первое число (поле ввода A)
  // Тип: string (потому что input.value всегда строка)
  const [a, setA] = useState('');
  
  // Второе число (поле ввода B)
  const [b, setB] = useState('');
  
  // Выбранная операция (+, -, *, /)
  // Начальное значение: '+' (сложение по умолчанию)
  const [op, setOp] = useState('+');
  
  // Результат вычисления
  // null означает "результата ещё нет"
  const [result, setResult] = useState(null);
  
  // Сообщение об ошибке (если запрос не удался)
  const [error, setError] = useState(null);
  
  // Индикатор загрузки (пока ждём ответ от сервера)
  const [loading, setLoading] = useState(false);


  // ═══════════════════════════════════════════════════════════════════════════
  // ФУНКЦИЯ ВЫЧИСЛЕНИЯ
  // ═══════════════════════════════════════════════════════════════════════════
  
  /*
   * calculate — асинхронная функция для отправки запроса на сервер
   *
   * async/await — синтаксис для работы с асинхронными операциями
   *
   * Что значит "асинхронный"?
   * HTTP-запрос занимает время (сеть, обработка на сервере).
   * Пока ждём ответ, JavaScript не блокируется — может делать другие вещи.
   * Когда ответ приходит, выполнение продолжается.
   *
   * async перед функцией означает:
   * - Функция всегда возвращает Promise
   * - Внутри можно использовать await
   *
   * await перед вызовом означает:
   * - Подожди, пока Promise разрешится
   * - Верни результат (или брось исключение при ошибке)
   */
  const calculate = async () => {
    
    // ─────────────────────────────────────────────────────────────────────────
    // ПОДГОТОВКА К ЗАПРОСУ
    // ─────────────────────────────────────────────────────────────────────────
    
    // Показываем индикатор загрузки
    setLoading(true);
    
    // Очищаем предыдущую ошибку (если была)
    setError(null);
    
    // ─────────────────────────────────────────────────────────────────────────
    // ОТПРАВКА HTTP-ЗАПРОСА
    // ─────────────────────────────────────────────────────────────────────────
    
    /*
     * try/catch — обработка ошибок
     *
     * Код внутри try выполняется.
     * Если происходит ошибка (throw), управление переходит в catch.
     * Это позволяет "поймать" ошибку и обработать её gracefully.
     */
    try {
      /*
       * fetch — встроенная функция браузера для HTTP-запросов
       *
       * Первый аргумент: URL
       * '/api/calc' — относительный путь
       * Браузер добавит текущий домен: http://localhost:3000/api/calc
       * nginx перенаправит этот запрос в backend
       *
       * Второй аргумент: настройки запроса
       */
      const response = await fetch('/api/calc', {
        // method: 'POST' — HTTP-метод
        // POST используется для отправки данных
        method: 'POST',
        
        // headers — HTTP-заголовки
        headers: {
          // Content-Type сообщает серверу формат данных в теле запроса
          // application/json — мы отправляем JSON
          'Content-Type': 'application/json'
        },
        
        // body — тело запроса
        // JSON.stringify() превращает JavaScript-объект в JSON-строку
        // 
        // parseFloat() превращает строку в число:
        // '10' → 10
        // '3.14' → 3.14
        body: JSON.stringify({
          a: parseFloat(a),  // Первое число
          b: parseFloat(b),  // Второе число
          op: op             // Операция
        })
      });
      
      /*
       * response.json() — парсим JSON из ответа
       *
       * Сервер вернул: {"result": 15.0, "operation": "10.0 + 5.0"}
       * .json() превращает это в JavaScript-объект:
       * { result: 15.0, operation: "10.0 + 5.0" }
       *
       * await нужен, потому что .json() возвращает Promise
       * (чтение тела ответа — асинхронная операция)
       */
      const data = await response.json();
      
      // Сохраняем результат в состояние
      // React перерендерит компонент и покажет результат
      setResult(data.result);
      
    } catch (err) {
      /*
       * Сюда попадаем, если:
       * - Нет сети (fetch не смог соединиться)
       * - Сервер вернул ошибку
       * - JSON не удалось распарсить
       */
      
      // Показываем сообщение об ошибке пользователю
      setError('Ошибка соединения с backend');
      
      // Для отладки выводим ошибку в консоль браузера
      console.error('Calculation error:', err);
    }
    
    // ─────────────────────────────────────────────────────────────────────────
    // ЗАВЕРШЕНИЕ ЗАПРОСА
    // ─────────────────────────────────────────────────────────────────────────
    
    // Скрываем индикатор загрузки
    // Это выполнится и при успехе, и при ошибке
    setLoading(false);
  };


  // ═══════════════════════════════════════════════════════════════════════════
  // СТИЛИ (CSS-in-JS)
  // ═══════════════════════════════════════════════════════════════════════════
  
  /*
   * CSS-in-JS — подход, когда стили описываются в JavaScript-объектах
   *
   * Преимущества:
   * - Стили рядом с компонентом (легко найти и изменить)
   * - Можно использовать JavaScript-логику в стилях
   * - Нет конфликтов имён классов
   *
   * Недостатки:
   * - Не кешируются браузером как CSS-файлы
   * - camelCase вместо kebab-case (backgroundColor вместо background-color)
   *
   * В реальных проектах часто используют:
   * - CSS Modules
   * - Styled Components
   * - Tailwind CSS
   */
  const styles = {
    // Контейнер всего калькулятора
    container: {
      maxWidth: '520px',           // Максимальная ширина
      margin: '50px auto',          // Отступ сверху + центрирование по горизонтали
      padding: '30px',              // Внутренние отступы
      fontFamily: 'Arial, sans-serif',  // Шрифт
      backgroundColor: '#f5f5f5',   // Светло-серый фон
      borderRadius: '10px',         // Скруглённые углы
      boxShadow: '0 2px 10px rgba(0,0,0,0.1)'  // Тень
    },
    
    // Заголовок
    title: {
      textAlign: 'center',          // Текст по центру
      color: '#333',                // Тёмно-серый цвет
      marginBottom: '20px'          // Отступ снизу
    },
    
    // Бейдж "Docker"
    badge: {
      display: 'inline-block',      // Inline, но с возможностью задать размеры
      backgroundColor: '#0db7ed',   // Голубой цвет Docker
      color: 'white',
      padding: '3px 8px',
      borderRadius: '4px',
      fontSize: '12px',
      marginLeft: '10px'
    },
    
    // Строка с полями ввода
    inputRow: {
      display: 'flex',              // Flexbox для горизонтального расположения
      gap: '10px',                  // Расстояние между элементами
      marginBottom: '15px',
      alignItems: 'center'          // Выравнивание по вертикали
    },
    
    // Поле ввода числа
    input: {
      flex: 1,                      // Занять доступное пространство
      minWidth: 0,                  // Разрешить сжиматься без переполнения
      padding: '10px',
      fontSize: '18px',
      border: '1px solid #ddd',
      borderRadius: '5px'
    },
    
    // Выпадающий список операций
    select: {
      padding: '10px',
      fontSize: '18px',
      border: '1px solid #ddd',
      borderRadius: '5px',
      backgroundColor: 'white',
      width: '90px',                // Фиксированная ширина, чтобы inputs не расползались
      flexShrink: 0                 // Не сжимать select
    },
    
    // Кнопка "Вычислить"
    button: {
      width: '100%',                // На всю ширину
      padding: '12px',
      fontSize: '18px',
      backgroundColor: '#4CAF50',   // Зелёный
      color: 'white',
      border: 'none',
      borderRadius: '5px',
      cursor: 'pointer'             // Курсор-указатель при наведении
    },
    
    // Блок с результатом
    result: {
      marginTop: '20px',
      padding: '15px',
      backgroundColor: '#e8f5e9',   // Светло-зелёный
      borderRadius: '5px',
      textAlign: 'center',
      fontSize: '24px'
    },
    
    // Блок с ошибкой
    error: {
      marginTop: '20px',
      padding: '15px',
      backgroundColor: '#ffebee',   // Светло-красный
      borderRadius: '5px',
      textAlign: 'center',
      color: '#c62828'              // Красный текст
    }
  };


  // ═══════════════════════════════════════════════════════════════════════════
  // РЕНДЕР (JSX)
  // ═══════════════════════════════════════════════════════════════════════════
  
  /*
   * return — возвращаем JSX (описание UI)
   *
   * JSX выглядит как HTML, но это JavaScript!
   * При компиляции превращается в вызовы React.createElement()
   *
   * Отличия от HTML:
   * - className вместо class (class — зарезервированное слово в JS)
   * - camelCase для атрибутов (onClick вместо onclick)
   * - {} для вставки JavaScript-выражений
   * - style принимает объект, не строку
   */
  return (
    // Главный контейнер
    // style={styles.container} — применяем стили из объекта
    <div style={styles.container}>
      
      {/* ═══════════════════════════════════════════════════════════════════
          ЗАГОЛОВОК
          ═══════════════════════════════════════════════════════════════════ */}
      <h1 style={styles.title}>
        Калькулятор
        {/* Бейдж "Docker" */}
        <span style={styles.badge}>Docker</span>
      </h1>
      
      {/* ═══════════════════════════════════════════════════════════════════
          СТРОКА ВВОДА
          ═══════════════════════════════════════════════════════════════════ */}
      <div style={styles.inputRow}>
        
        {/* ─────────────────────────────────────────────────────────────────
            Поле ввода A (первое число)
            ───────────────────────────────────────────────────────────────── */}
        <input
          style={styles.input}
          type="number"           // Тип: числовое поле (с кнопками +/-)
          value={a}               // Значение из состояния
          /*
           * onChange — обработчик изменения
           * 
           * Вызывается каждый раз, когда пользователь что-то вводит.
           * e (event) — объект события
           * e.target — элемент, на котором произошло событие (input)
           * e.target.value — текущее значение input
           *
           * (e) => setA(e.target.value) — arrow function
           * При каждом изменении обновляем состояние a
           *
           * Это называется "controlled component" — React контролирует
           * значение input через состояние.
           */
          onChange={(e) => setA(e.target.value)}
          placeholder="Число A"   // Подсказка в пустом поле
        />
        
        {/* ─────────────────────────────────────────────────────────────────
            Выбор операции
            ───────────────────────────────────────────────────────────────── */}
        <select
          style={styles.select}
          value={op}              // Выбранное значение из состояния
          onChange={(e) => setOp(e.target.value)}
        >
          {/* option — пункт выпадающего списка */}
          {/* value — значение, которое будет в op */}
          <option value="+">+</option>
          <option value="-">−</option>   {/* − это минус (не дефис) */}
          <option value="*">×</option>   {/* × это знак умножения */}
          <option value="/">÷</option>   {/* ÷ это знак деления */}
        </select>
        
        {/* ─────────────────────────────────────────────────────────────────
            Поле ввода B (второе число)
            ───────────────────────────────────────────────────────────────── */}
        <input
          style={styles.input}
          type="number"
          value={b}
          onChange={(e) => setB(e.target.value)}
          placeholder="Число B"
        />
      </div>
      
      {/* ═══════════════════════════════════════════════════════════════════
          КНОПКА ВЫЧИСЛЕНИЯ
          ═══════════════════════════════════════════════════════════════════ */}
      <button
        style={styles.button}
        onClick={calculate}       // При клике вызываем функцию calculate
        /*
         * disabled — отключить кнопку
         *
         * Кнопка отключена если:
         * - loading === true (запрос в процессе)
         * - !a (поле A пустое; '' — falsy значение)
         * - !b (поле B пустое)
         *
         * || — логическое ИЛИ
         * Если хотя бы одно условие true — кнопка отключена
         */
        disabled={loading || !a || !b}
      >
        {/*
         * Текст кнопки зависит от состояния loading
         *
         * Тернарный оператор: условие ? значение_если_true : значение_если_false
         *
         * Если loading === true — показываем "Считаем..."
         * Иначе — показываем "Вычислить"
         */}
        {loading ? 'Считаем...' : 'Вычислить'}
      </button>
      
      {/* ═══════════════════════════════════════════════════════════════════
          РЕЗУЛЬТАТ (условный рендеринг)
          ═══════════════════════════════════════════════════════════════════ */}
      {/*
       * Условный рендеринг в React
       *
       * {result !== null && <div>...</div>}
       *
       * Как работает:
       * - Если result === null, выражение вернёт null (ничего не рендерится)
       * - Если result !== null, вернётся <div>...</div>
       *
       * Это идиома React для "показать элемент, только если условие true"
       */}
      {result !== null && (
        <div style={styles.result}>
          Результат: <strong>{result}</strong>
        </div>
      )}
      
      {/* ═══════════════════════════════════════════════════════════════════
          ОШИБКА (условный рендеринг)
          ═══════════════════════════════════════════════════════════════════ */}
      {/*
       * Аналогично результату:
       * Показываем блок ошибки, только если error !== null
       */}
      {error && (
        <div style={styles.error}>{error}</div>
      )}
    </div>
  );
}


// ─────────────────────────────────────────────────────────────────────────────
// ЭКСПОРТ
// ─────────────────────────────────────────────────────────────────────────────

/*
 * export default — экспорт по умолчанию
 *
 * Позволяет импортировать компонент в других файлах:
 * import App from './App'
 *
 * "default" означает, что при импорте не нужны фигурные скобки
 * и можно использовать любое имя:
 * import MyApp from './App'  // тоже работает
 */
export default App;

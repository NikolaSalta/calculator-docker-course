/*
 * ═══════════════════════════════════════════════════════════════════════════
 * CalcController.java — REST API контроллер калькулятора
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Что такое REST API?
 * REST (Representational State Transfer) — стиль архитектуры API.
 * Основные принципы:
 * - Клиент-сервер: клиент отправляет запрос, сервер отвечает
 * - Stateless: сервер не хранит состояние между запросами
 * - Единообразный интерфейс: стандартные HTTP-методы (GET, POST, PUT, DELETE)
 *
 * Что такое контроллер?
 * Контроллер — это класс, который обрабатывает HTTP-запросы.
 * Каждый метод контроллера соответствует определённому URL (эндпоинту).
 * ═══════════════════════════════════════════════════════════════════════════
 */

package com.example.calc;

// Импорты Spring Web
import org.springframework.web.bind.annotation.*;

// Map — структура данных "ключ-значение" (как словарь)
import java.util.Map;

/*
 * @RestController — аннотация, объединяющая:
 * 
 * 1. @Controller — этот класс обрабатывает HTTP-запросы
 * 
 * 2. @ResponseBody — возвращаемое значение методов автоматически
 *    преобразуется в JSON и отправляется клиенту
 * 
 * Без @ResponseBody пришлось бы вручную создавать ResponseEntity
 * и сериализовать объекты в JSON.
 */
@RestController

/*
 * @RequestMapping("/api") — базовый путь для всех эндпоинтов класса
 * 
 * Все методы этого контроллера будут начинаться с /api:
 * - /api/calc
 * - /api/health
 */
@RequestMapping("/api")

/*
 * @CrossOrigin(origins = "*") — разрешить запросы с любого домена
 * 
 * Что такое CORS?
 * Cross-Origin Resource Sharing — политика безопасности браузера.
 * По умолчанию браузер запрещает JavaScript делать запросы
 * на другой домен/порт (cross-origin).
 * 
 * Пример: страница на localhost:3000 не может запросить localhost:8080
 * 
 * @CrossOrigin говорит серверу добавить заголовок:
 * Access-Control-Allow-Origin: *
 * 
 * Это разрешает браузеру делать запросы с любого источника.
 * В продакшене лучше указать конкретные домены вместо "*".
 * 
 * Примечание: в нашем проекте nginx проксирует запросы,
 * поэтому CORS не нужен. Но мы добавляем на всякий случай
 * для тестирования напрямую через localhost:8080.
 */
@CrossOrigin(origins = "*")
public class CalcController {
    
    /*
     * ═══════════════════════════════════════════════════════════════════════
     * POST /api/calc — выполнить вычисление
     * ═══════════════════════════════════════════════════════════════════════
     * 
     * @PostMapping("/calc") — обрабатывать POST-запросы на /api/calc
     * 
     * Почему POST, а не GET?
     * - GET для получения данных (без изменений на сервере)
     * - POST для отправки данных (создание, вычисление)
     * 
     * Хотя калькулятор не изменяет состояние, мы используем POST,
     * потому что отправляем данные в теле запроса (JSON).
     */
    @PostMapping("/calc")
    public Map<String, Object> calculate(
        /*
         * @RequestBody — взять тело HTTP-запроса и преобразовать в объект
         * 
         * Клиент отправляет JSON:
         * {"a": 10, "b": 5, "op": "+"}
         * 
         * Spring автоматически (через Jackson) преобразует его в Map:
         * Map содержит: "a" -> 10, "b" -> 5, "op" -> "+"
         * 
         * Map<String, Object> — карта со строковыми ключами
         * и значениями любого типа (числа, строки)
         */
        @RequestBody Map<String, Object> request
    ) {
        /*
         * Извлекаем значения из Map
         * 
         * request.get("a") возвращает Object
         * (Number) — приводим к типу Number (общий тип для Integer, Double)
         * .doubleValue() — получаем double
         */
        double a = ((Number) request.get("a")).doubleValue();
        double b = ((Number) request.get("b")).doubleValue();
        String op = (String) request.get("op");
        
        /*
         * Вычисляем результат
         * 
         * switch expression (Java 14+) — современный синтаксис switch
         * Вместо:
         *   switch (op) {
         *     case "+": result = a + b; break;
         *     ...
         *   }
         * 
         * Пишем компактно:
         *   double result = switch (op) {
         *     case "+" -> a + b;
         *     ...
         *   };
         * 
         * -> вместо : и не нужен break
         */
        double result = switch (op) {
            case "+" -> a + b;      // Сложение
            case "-" -> a - b;      // Вычитание
            case "*" -> a * b;      // Умножение
            case "/" -> b != 0      // Деление (с проверкой на ноль)
                ? a / b 
                : Double.NaN;       // NaN = Not a Number (результат деления на 0)
            /*
             * default — если op не совпадает ни с одним case
             * Бросаем исключение с понятным сообщением
             */
            default -> throw new IllegalArgumentException("Unknown operation: " + op);
        };
        
        /*
         * Возвращаем результат
         * 
         * Map.of() — создаёт неизменяемую карту (Java 9+)
         * 
         * Spring автоматически преобразует Map в JSON:
         * {"result": 15.0, "operation": "10.0 + 5.0"}
         */
        return Map.of(
            "result", result,                           // Числовой результат
            "operation", a + " " + op + " " + b         // Текстовое описание
        );
    }
    
    /*
     * ═══════════════════════════════════════════════════════════════════════
     * GET /api/health — проверка здоровья сервиса
     * ═══════════════════════════════════════════════════════════════════════
     * 
     * @GetMapping("/health") — обрабатывать GET-запросы на /api/health
     * 
     * Health check (проверка здоровья) — стандартный паттерн:
     * - Мониторинг вызывает этот эндпоинт
     * - Если ответ 200 OK — сервис жив
     * - Если таймаут или ошибка — сервис упал
     * 
     * Используется в:
     * - Docker healthcheck
     * - Kubernetes liveness/readiness probes
     * - Load balancer health checks
     */
    @GetMapping("/health")
    public Map<String, String> health() {
        /*
         * Возвращаем простой JSON с информацией о сервисе
         * 
         * В реальном приложении здесь можно проверять:
         * - Соединение с базой данных
         * - Доступность внешних сервисов
         * - Наличие свободной памяти
         */
        return Map.of(
            "status", "OK",                 // Статус сервиса
            "service", "calc-backend"       // Имя сервиса (для логов)
        );
    }
}

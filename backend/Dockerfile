# ═══════════════════════════════════════════════════════════════════════════
# Dockerfile для Backend (Java Spring Boot)
# ═══════════════════════════════════════════════════════════════════════════
#
# Это multi-stage build (многоэтапная сборка):
# - Этап 1 (builder): компилируем Java-код в JAR-файл
# - Этап 2 (runtime): запускаем готовый JAR в минимальном образе
#
# Зачем multi-stage?
# - Образ для сборки большой (Maven + JDK = ~400MB)
# - Образ для запуска маленький (только JRE = ~150MB)
# - Исходники не попадают в финальный образ (безопасность)
# ═══════════════════════════════════════════════════════════════════════════


# ┌─────────────────────────────────────────────────────────────────────────┐
# │ ЭТАП 1: СБОРКА (builder)                                                │
# └─────────────────────────────────────────────────────────────────────────┘

# FROM — базовый образ, от которого наследуемся
# maven:3.9-eclipse-temurin-17 содержит:
# - Maven 3.9 (инструмент сборки Java)
# - Eclipse Temurin JDK 17 (Java Development Kit)
# AS builder — имя этапа, на него можно ссылаться позже
FROM maven:3.9.6-eclipse-temurin-17 AS builder

# WORKDIR — установить рабочую директорию
# Все последующие команды выполняются в этой папке
# Если папки нет — она создастся автоматически
WORKDIR /app

# COPY — скопировать файлы с хоста в контейнер
# Сначала копируем только pom.xml (конфигурация Maven)
# Это позволяет кешировать зависимости отдельно от кода
COPY pom.xml .

# COPY — копируем исходный код
# ./src на хосте → ./src в контейнере
COPY src ./src

# RUN — выполнить команду во время сборки образа
# mvn clean package — компилирует Java-код и создаёт JAR-файл
# -DskipTests — пропустить тесты (ускоряет сборку)
# Результат: файл target/*.jar
RUN mvn clean package -DskipTests


# ┌─────────────────────────────────────────────────────────────────────────┐
# │ ЭТАП 2: ЗАПУСК (runtime)                                                │
# └─────────────────────────────────────────────────────────────────────────┘

# Используем минимальный образ только с JRE (Java Runtime Environment)
# eclipse-temurin:17-jre — JRE 17 (поддерживает ARM и x86)
# Примечание: alpine-версия не поддерживает Apple Silicon (ARM),
# поэтому используем стандартную версию
FROM eclipse-temurin:17.0.10_7-jre

# Создаем пользователя appuser для запуска приложения без прав root
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Снова устанавливаем рабочую директорию
WORKDIR /app

# COPY --from=builder — копируем файл из предыдущего этапа
# /app/target/*.jar — скомпилированный JAR из этапа builder
# app.jar — имя файла в текущем образе
# Меняем владельца файла на appuser
COPY --from=builder --chown=appuser:appuser /app/target/*.jar app.jar

# EXPOSE — документирует порт, который использует приложение
# Это НЕ открывает порт! Только документация.
# Реальный проброс порта делается через -p при docker run
EXPOSE 8080

# Переключаемся на пользователя appuser
USER appuser

# CMD — команда, которая выполнится при запуске контейнера
# Формат JSON-массива: ["исполняемый файл", "аргумент1", "аргумент2"]
# java -jar app.jar — запустить Spring Boot приложение
CMD ["java", "-jar", "app.jar"]

"""
═══════════════════════════════════════════════════════════════════════════════
test_api.py — API-тесты калькулятора
═══════════════════════════════════════════════════════════════════════════════

Что тестируют эти тесты?
───────────────────────────────────────────
Эти тесты проверяют backend через HTTP-запросы напрямую.
Они НЕ используют браузер — только requests библиотеку.

Категории тестов в этом файле:
───────────────────────────────────────────
1. Smoke tests — базовая проверка "оно вообще работает?"
2. API tests — проверка бизнес-логики (правильность вычислений)
3. Integration tests — проверка связки frontend-backend (прокси)

Как запустить:
───────────────────────────────────────────
# Все тесты из этого файла
pytest test_api.py -v

# Только smoke тесты
pytest test_api.py -m smoke

# Только API тесты
pytest test_api.py -m api
═══════════════════════════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════════════════════════
# ИМПОРТЫ
# ═══════════════════════════════════════════════════════════════════════════════

# pytest — фреймворк тестирования
# pytest.mark — для маркеров (@pytest.mark.smoke)
# pytest.approx — для сравнения float с допуском
import pytest

# requests — библиотека для HTTP-запросов
# Позволяет делать GET, POST, PUT, DELETE запросы
import requests

# Наши настройки (URL сервисов, таймауты)
from test_config import BACKEND_URL, FRONTEND_URL, REQUEST_TIMEOUT


# ═══════════════════════════════════════════════════════════════════════════════
# SMOKE TESTS — Базовая проверка работоспособности
# ═══════════════════════════════════════════════════════════════════════════════

class TestSmoke:
    """
    Smoke-тесты: быстрая проверка что система живая.
    
    Что такое Smoke test?
    ─────────────────────────────────────────
    Название пришло из электроники: "Включи устройство — если не задымилось,
    базовый тест пройден".
    
    Smoke-тесты должны:
    - Выполняться за секунды (не минуты)
    - Проверять только базовую работоспособность
    - Запускаться ПЕРВЫМИ, до остальных тестов
    - Дать быстрый ответ: "система вообще работает или нет?"
    
    Если smoke-тесты падают — нет смысла запускать остальные.
    """
    
    @pytest.mark.smoke
    def test_backend_health(self):
        """
        Backend отвечает на health-check.
        
        Что проверяем:
        ─────────────────────────────────────────
        1. Backend запущен и принимает HTTP-запросы
        2. Endpoint /api/health существует
        3. Возвращается статус 200 OK
        4. В ответе есть {"status": "OK"}
        
        Почему это важно:
        ─────────────────────────────────────────
        Health endpoint используется для:
        - Docker healthcheck
        - Kubernetes liveness probe
        - Load balancer health check
        - Мониторинг (Prometheus, Grafana)
        
        Если health не работает — сервис считается "мёртвым".
        """
        # Делаем HTTP GET запрос на health endpoint
        # requests.get() возвращает объект Response
        url = f"{BACKEND_URL}/api/health"
        print(f"\n🔍 Проверяю health endpoint: {url}")
        
        resp = requests.get(url, timeout=REQUEST_TIMEOUT)
        
        print(f"✅ Статус-код: {resp.status_code}")
        print(f"✅ Ответ: {resp.json()}")
        
        # ─────────────────────────────────────────────────────────────────────
        # ASSERTIONS (проверки)
        # ─────────────────────────────────────────────────────────────────────
        
        # Проверяем HTTP статус-код
        assert resp.status_code == 200, f"Ожидали 200, получили {resp.status_code}"
        
        # Проверяем тело ответа
        data = resp.json()
        assert data["status"] == "OK", f"Ожидали status='OK', получили {data}"
    
    @pytest.mark.smoke
    def test_frontend_available(self):
        """
        Frontend отдаёт HTML-страницу.
        
        Что проверяем:
        ─────────────────────────────────────────
        1. nginx запущен и отвечает
        2. React-приложение собралось и отдаётся
        3. Тип контента — HTML (не ошибка, не JSON)
        """
        # GET-запрос на главную страницу frontend
        resp = requests.get(FRONTEND_URL, timeout=REQUEST_TIMEOUT)
        
        # Проверяем статус
        assert resp.status_code == 200
        
        # Проверяем Content-Type заголовок
        # Должен содержать "text/html"
        #
        # resp.headers — словарь HTTP-заголовков ответа
        # .get("Content-Type", "") — безопасное получение
        #   (вернёт "" если заголовка нет, а не бросит исключение)
        assert "text/html" in resp.headers.get("Content-Type", "")


# ═══════════════════════════════════════════════════════════════════════════════
# API TESTS — Тесты бизнес-логики
# ═══════════════════════════════════════════════════════════════════════════════

class TestCalculatorAPI:
    """
    Тесты API калькулятора.
    
    Проверяют бизнес-логику: правильно ли калькулятор считает?
    """
    
    @pytest.mark.api
    @pytest.mark.parametrize("a,b,op,expected", [
        # ─────────────────────────────────────────────────────────────────────
        # PARAMETRIZE — создание множества тестов из одной функции
        # ─────────────────────────────────────────────────────────────────────
        #
        # @pytest.mark.parametrize("имена_параметров", [список_значений])
        #
        # Каждый кортеж в списке — отдельный тест:
        # (a, b, op, expected) — значения параметров для теста
        #
        # Вместо написания 6 отдельных функций test_add, test_sub, ...
        # мы пишем ОДНУ функцию и 6 наборов данных.
        #
        # pytest покажет каждый набор как отдельный тест:
        # test_operations[10-5-+-15.0] PASSED
        # test_operations[10-5---5.0] PASSED
        # и т.д.
        # ─────────────────────────────────────────────────────────────────────
        
        # Базовые операции
        (10, 5, "+", 15.0),   # 10 + 5 = 15
        (10, 5, "-", 5.0),    # 10 - 5 = 5
        (10, 5, "*", 50.0),   # 10 * 5 = 50
        (10, 5, "/", 2.0),    # 10 / 5 = 2
        
        # Граничные случаи (edge cases)
        (-5, 3, "+", -2.0),   # Отрицательные числа: -5 + 3 = -2
        (0, 100, "*", 0.0),   # Умножение на ноль: 0 * 100 = 0
    ])
    def test_operations(self, a, b, op, expected):
        """
        Базовые арифметические операции.
        
        Параметры (из @parametrize):
        ─────────────────────────────────────────
        a : float
            Первое число
        b : float  
            Второе число
        op : str
            Операция (+, -, *, /)
        expected : float
            Ожидаемый результат
        """
        # Делаем POST-запрос на API калькулятора
        payload = {"a": a, "b": b, "op": op}
        print(f"\n🧮 Тест: {a} {op} {b} = {expected}")
        print(f"📤 Отправляю: {payload}")
        
        resp = requests.post(
            f"{BACKEND_URL}/api/calc",
            json=payload,
            timeout=REQUEST_TIMEOUT
        )
        
        data = resp.json()
        print(f"📥 Получил: {data}")
        
        # Проверяем статус
        assert resp.status_code == 200, f"Ожидали 200, получили {resp.status_code}"
        
        # Проверяем результат с допуском для float
        result = data["result"]
        assert result == pytest.approx(expected), f"Ожидали {expected}, получили {result}"
        print(f"✅ Результат корректен: {result}")
    
    @pytest.mark.api
    def test_division_by_zero(self):
        """
        Деление на ноль.
        
        Это важный edge case (граничный случай).
        
        Что проверяем:
        ─────────────────────────────────────────
        1. Сервер возвращает 400 Bad Request (валидационная ошибка)
        2. В ответе есть понятное сообщение об ошибке
        3. Приложение НЕ падает (не 500 Internal Server Error)
        
        Почему 400, а не 200:
        ─────────────────────────────────────────
        Деление на ноль — это ошибка входных данных.
        Клиент должен получить понятную ошибку, а не странный результат.
        """
        resp = requests.post(
            f"{BACKEND_URL}/api/calc",
            json={"a": 10, "b": 0, "op": "/"},
            timeout=REQUEST_TIMEOUT
        )
        
        # Ожидаем 400 Bad Request с сообщением об ошибке
        assert resp.status_code == 400, f"Ожидали 400, получили {resp.status_code}"
        
        # Проверяем что в ответе есть сообщение об ошибке
        data = resp.json()
        assert "message" in data, "Ожидали message в ответе"
        assert "zero" in data["message"].lower(), f"Ожидали упоминание zero в: {data['message']}"


# ═══════════════════════════════════════════════════════════════════════════════
# INTEGRATION TESTS — Тесты интеграции компонентов
# ═══════════════════════════════════════════════════════════════════════════════

class TestIntegration:
    """
    Интеграционные тесты: проверка связки frontend-backend.
    
    Что такое интеграционный тест?
    ─────────────────────────────────────────
    Интеграционный тест проверяет взаимодействие нескольких компонентов.
    
    В нашем случае:
    - Frontend (nginx) получает запрос на /api/calc
    - nginx проксирует его в backend
    - backend вычисляет результат
    - Ответ идёт обратно: backend → nginx → клиент
    
    Это отличается от unit-теста, который проверяет один компонент изолированно.
    """
    
    @pytest.mark.api
    def test_frontend_proxy(self):
        """
        Frontend корректно проксирует /api в backend.
        
        Почему это ключевой тест:
        ─────────────────────────────────────────
        В браузере JavaScript делает запросы на /api/calc.
        Эти запросы идут на тот же домен, откуда загружена страница (frontend).
        nginx должен перенаправить их в backend.
        
        Если прокси не работает:
        - UI загрузится
        - Но вычисления не будут работать
        - Пользователь увидит ошибку "Ошибка соединения с backend"
        
        Путь запроса в этом тесте:
        ─────────────────────────────────────────
        1. Тест → Frontend (http://frontend:80/api/calc)
        2. nginx видит /api → proxy_pass http://backend:8080
        3. Backend получает запрос → вычисляет → отвечает
        4. nginx → тест
        """
        # ВАЖНО: запрос на FRONTEND, не на backend!
        # URL: http://frontend:80/api/calc
        resp = requests.post(
            f"{FRONTEND_URL}/api/calc",  # Frontend URL, не backend!
            json={"a": 7, "b": 3, "op": "*"},
            timeout=REQUEST_TIMEOUT
        )
        
        # Если прокси работает — получим результат от backend
        assert resp.status_code == 200
        assert resp.json()["result"] == 21.0  # 7 * 3 = 21

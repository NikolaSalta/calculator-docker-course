"""
═══════════════════════════════════════════════════════════════════════════════
test_api.py — API-тесты калькулятора
═══════════════════════════════════════════════════════════════════════════════

Что тестируют эти тесты?
───────────────────────────────────────────
Эти тесты проверяют backend через HTTP-запросы напрямую.
Они НЕ используют браузер — только requests библиотеку.

Категории тестов в этом файле:
───────────────────────────────────────────
1. Smoke tests — базовая проверка "оно вообще работает?"
2. API tests — проверка бизнес-логики (правильность вычислений)
3. Integration tests — проверка связки frontend-backend (прокси)

Как запустить:
───────────────────────────────────────────
# Все тесты из этого файла
pytest test_api.py -v

# Только smoke тесты
pytest test_api.py -m smoke

# Только API тесты
pytest test_api.py -m api
═══════════════════════════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════════════════════════
# ИМПОРТЫ
# ═══════════════════════════════════════════════════════════════════════════════

# pytest — фреймворк тестирования
# pytest.mark — для маркеров (@pytest.mark.smoke)
# pytest.approx — для сравнения float с допуском
import pytest

# requests — библиотека для HTTP-запросов
# Позволяет делать GET, POST, PUT, DELETE запросы
import requests

# Наши настройки (URL сервисов, таймауты)
from test_config import BACKEND_URL, FRONTEND_URL, REQUEST_TIMEOUT


# ═══════════════════════════════════════════════════════════════════════════════
# SMOKE TESTS — Базовая проверка работоспособности
# ═══════════════════════════════════════════════════════════════════════════════

class TestSmoke:
    """
    Smoke-тесты: быстрая проверка что система живая.
    
    Что такое Smoke test?
    ─────────────────────────────────────────
    Название пришло из электроники: "Включи устройство — если не задымилось,
    базовый тест пройден".
    
    Smoke-тесты должны:
    - Выполняться за секунды (не минуты)
    - Проверять только базовую работоспособность
    - Запускаться ПЕРВЫМИ, до остальных тестов
    - Дать быстрый ответ: "система вообще работает или нет?"
    
    Если smoke-тесты падают — нет смысла запускать остальные.
    """
    
    @pytest.mark.smoke
    def test_backend_health(self):
        """
        Backend отвечает на health-check.
        
        Что проверяем:
        ─────────────────────────────────────────
        1. Backend запущен и принимает HTTP-запросы
        2. Endpoint /api/health существует
        3. Возвращается статус 200 OK
        4. В ответе есть {"status": "OK"}
        
        Почему это важно:
        ─────────────────────────────────────────
        Health endpoint используется для:
        - Docker healthcheck
        - Kubernetes liveness probe
        - Load balancer health check
        - Мониторинг (Prometheus, Grafana)
        
        Если health не работает — сервис считается "мёртвым".
        """
        # Делаем HTTP GET запрос на health endpoint
        # requests.get() возвращает объект Response
        resp = requests.get(
            f"{BACKEND_URL}/api/health",  # URL: http://backend:8080/api/health
            timeout=REQUEST_TIMEOUT        # Максимум ждать 10 сек
        )
        
        # ─────────────────────────────────────────────────────────────────────
        # ASSERTIONS (проверки)
        # ─────────────────────────────────────────────────────────────────────
        #
        # assert — это утверждение: "я утверждаю, что это правда"
        # Если утверждение ложно — тест падает
        #
        # Формат: assert условие, "сообщение об ошибке"
        # ─────────────────────────────────────────────────────────────────────
        
        # Проверяем HTTP статус-код
        # 200 = OK (запрос успешен)
        # 404 = Not Found
        # 500 = Internal Server Error
        assert resp.status_code == 200
        
        # Проверяем тело ответа
        # .json() парсит JSON-строку в Python-словарь
        # Например: '{"status": "OK"}' → {"status": "OK"}
        assert resp.json()["status"] == "OK"
    
    @pytest.mark.smoke
    def test_frontend_available(self):
        """
        Frontend отдаёт HTML-страницу.
        
        Что проверяем:
        ─────────────────────────────────────────
        1. nginx запущен и отвечает
        2. React-приложение собралось и отдаётся
        3. Тип контента — HTML (не ошибка, не JSON)
        """
        # GET-запрос на главную страницу frontend
        resp = requests.get(FRONTEND_URL, timeout=REQUEST_TIMEOUT)
        
        # Проверяем статус
        assert resp.status_code == 200
        
        # Проверяем Content-Type заголовок
        # Должен содержать "text/html"
        #
        # resp.headers — словарь HTTP-заголовков ответа
        # .get("Content-Type", "") — безопасное получение
        #   (вернёт "" если заголовка нет, а не бросит исключение)
        assert "text/html" in resp.headers.get("Content-Type", "")


# ═══════════════════════════════════════════════════════════════════════════════
# API TESTS — Тесты бизнес-логики
# ═══════════════════════════════════════════════════════════════════════════════

class TestCalculatorAPI:
    """
    Тесты API калькулятора.
    
    Проверяют бизнес-логику: правильно ли калькулятор считает?
    """
    
    @pytest.mark.api
    @pytest.mark.parametrize("a,b,op,expected", [
        # ─────────────────────────────────────────────────────────────────────
        # PARAMETRIZE — создание множества тестов из одной функции
        # ─────────────────────────────────────────────────────────────────────
        #
        # @pytest.mark.parametrize("имена_параметров", [список_значений])
        #
        # Каждый кортеж в списке — отдельный тест:
        # (a, b, op, expected) — значения параметров для теста
        #
        # Вместо написания 6 отдельных функций test_add, test_sub, ...
        # мы пишем ОДНУ функцию и 6 наборов данных.
        #
        # pytest покажет каждый набор как отдельный тест:
        # test_operations[10-5-+-15.0] PASSED
        # test_operations[10-5---5.0] PASSED
        # и т.д.
        # ─────────────────────────────────────────────────────────────────────
        
        # Базовые операции
        (10, 5, "+", 15.0),   # 10 + 5 = 15
        (10, 5, "-", 5.0),    # 10 - 5 = 5
        (10, 5, "*", 50.0),   # 10 * 5 = 50
        (10, 5, "/", 2.0),    # 10 / 5 = 2
        
        # Граничные случаи (edge cases)
        (-5, 3, "+", -2.0),   # Отрицательные числа: -5 + 3 = -2
        (0, 100, "*", 0.0),   # Умножение на ноль: 0 * 100 = 0
    ])
    def test_operations(self, a, b, op, expected):
        """
        Базовые арифметические операции.
        
        Параметры (из @parametrize):
        ─────────────────────────────────────────
        a : float
            Первое число
        b : float  
            Второе число
        op : str
            Операция (+, -, *, /)
        expected : float
            Ожидаемый результат
        """
        # Делаем POST-запрос на API калькулятора
        resp = requests.post(
            f"{BACKEND_URL}/api/calc",       # URL эндпоинта
            json={"a": a, "b": b, "op": op}, # Тело запроса (автоматически в JSON)
            timeout=REQUEST_TIMEOUT           # Таймаут
        )
        
        # Проверяем статус
        assert resp.status_code == 200
        
        # Проверяем результат
        # ─────────────────────────────────────────────────────────────────────
        # pytest.approx() — сравнение float с допуском
        # ─────────────────────────────────────────────────────────────────────
        #
        # Почему не просто assert result == expected?
        #
        # Числа с плавающей точкой (float) имеют ограниченную точность.
        # Пример: 0.1 + 0.2 = 0.30000000000000004 (а не ровно 0.3)
        #
        # pytest.approx() сравнивает с допуском:
        # pytest.approx(15.0) ≈ 15.0 ± небольшая погрешность
        #
        # По умолчанию допуск = 1e-6 (0.000001)
        # Можно указать явно: pytest.approx(15.0, rel=0.01) — 1% допуск
        # ─────────────────────────────────────────────────────────────────────
        assert resp.json()["result"] == pytest.approx(expected)
    
    @pytest.mark.api
    def test_division_by_zero(self):
        """
        Деление на ноль.
        
        Это важный edge case (граничный случай).
        
        Что может произойти:
        ─────────────────────────────────────────
        1. Приложение падает с exception → 500 Internal Server Error (плохо)
        2. Приложение возвращает ошибку → 400 Bad Request (нормально)
        3. Java возвращает Infinity или NaN → 200 OK (наш случай)
        
        В Java: 10.0 / 0.0 = Infinity (бесконечность)
        JSON: {"result": "Infinity"} или {"result": null}
        """
        resp = requests.post(
            f"{BACKEND_URL}/api/calc",
            json={"a": 10, "b": 0, "op": "/"},
            timeout=REQUEST_TIMEOUT
        )
        
        # Главное — приложение НЕ упало (не 500)
        # 200 OK — валидный ответ, даже если result странный
        assert resp.status_code == 200


# ═══════════════════════════════════════════════════════════════════════════════
# INTEGRATION TESTS — Тесты интеграции компонентов
# ═══════════════════════════════════════════════════════════════════════════════

class TestIntegration:
    """
    Интеграционные тесты: проверка связки frontend-backend.
    
    Что такое интеграционный тест?
    ─────────────────────────────────────────
    Интеграционный тест проверяет взаимодействие нескольких компонентов.
    
    В нашем случае:
    - Frontend (nginx) получает запрос на /api/calc
    - nginx проксирует его в backend
    - backend вычисляет результат
    - Ответ идёт обратно: backend → nginx → клиент
    
    Это отличается от unit-теста, который проверяет один компонент изолированно.
    """
    
    @pytest.mark.api
    def test_frontend_proxy(self):
        """
        Frontend корректно проксирует /api в backend.
        
        Почему это ключевой тест:
        ─────────────────────────────────────────
        В браузере JavaScript делает запросы на /api/calc.
        Эти запросы идут на тот же домен, откуда загружена страница (frontend).
        nginx должен перенаправить их в backend.
        
        Если прокси не работает:
        - UI загрузится
        - Но вычисления не будут работать
        - Пользователь увидит ошибку "Ошибка соединения с backend"
        
        Путь запроса в этом тесте:
        ─────────────────────────────────────────
        1. Тест → Frontend (http://frontend:80/api/calc)
        2. nginx видит /api → proxy_pass http://backend:8080
        3. Backend получает запрос → вычисляет → отвечает
        4. nginx → тест
        """
        # ВАЖНО: запрос на FRONTEND, не на backend!
        # URL: http://frontend:80/api/calc
        resp = requests.post(
            f"{FRONTEND_URL}/api/calc",  # Frontend URL, не backend!
            json={"a": 7, "b": 3, "op": "*"},
            timeout=REQUEST_TIMEOUT
        )
        
        # Если прокси работает — получим результат от backend
        assert resp.status_code == 200
        assert resp.json()["result"] == 21.0  # 7 * 3 = 21

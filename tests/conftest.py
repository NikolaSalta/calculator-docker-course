"""
═══════════════════════════════════════════════════════════════════════════════
conftest.py — Общие fixtures для всех тестов
═══════════════════════════════════════════════════════════════════════════════

Что такое conftest.py?
──────────────────────────────────────────
conftest.py — специальный файл pytest. Он автоматически загружается
и его содержимое доступно всем тестам в директории.

Не нужно ничего импортировать! pytest сам найдёт fixtures из conftest.py.

Что такое fixture?
──────────────────────────────────────────
Fixture (фикстура) — это функция, которая подготавливает что-то для теста.

Примеры:
- Создать подключение к базе данных
- Запустить браузер
- Подготовить тестовые данные
- Дождаться готовности сервисов

Fixture может также "убрать за собой" после теста (teardown).

Как использовать fixture в тесте:
──────────────────────────────────────────
def test_example(browser):  # Просто добавь параметр с именем fixture
    browser.get("http://example.com")
    assert "Example" in browser.title

pytest автоматически:
1. Вызовет fixture browser()
2. Передаст результат в тест
3. После теста выполнит cleanup (если есть yield)

Scope (область действия) fixture:
──────────────────────────────────────────
- scope="function" — создаётся для каждого теста (по умолчанию)
- scope="class" — один раз для класса
- scope="module" — один раз для файла
- scope="session" — один раз для всего запуска pytest
═══════════════════════════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════════════════════════
# ИМПОРТЫ
# ═══════════════════════════════════════════════════════════════════════════════

# pytest — фреймворк тестирования
# pytest.fixture — декоратор для создания fixtures
import pytest

# pytest_html — для добавления контента в HTML-отчёт
from pytest_html import extras

# requests — библиотека для HTTP-запросов
# Используем для проверки готовности сервисов
import requests

# time — работа со временем
# time.sleep() — пауза, time.time() — текущее время
import time

# selenium.webdriver — управление браузером
from selenium import webdriver

# Options — настройки браузера (headless mode, window size, etc.)
from selenium.webdriver.chrome.options import Options as ChromeOptions

# Импортируем наши настройки
from test_config import (
    BACKEND_URL,
    FRONTEND_URL,
    SELENIUM_HUB_URL,
    SELENIUM_REMOTE_URL,
    STARTUP_WAIT,
    BROWSER,
    HEADLESS
)


# ═══════════════════════════════════════════════════════════════════════════════
# ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ: ожидание URL
# ═══════════════════════════════════════════════════════════════════════════════

def wait_for_url(url, timeout, name):
    """
    Ждёт, пока URL станет доступен.
    
    Эта функция используется для ожидания готовности сервисов.
    В Docker контейнеры запускаются не мгновенно — нужно подождать.
    
    Как работает:
    ─────────────────────────────────────────
    1. Запоминаем время начала
    2. В цикле пытаемся сделать HTTP GET-запрос
    3. Если успешно (200 OK) — возвращаем True
    4. Если ошибка — ждём 1 секунду и пробуем снова
    5. Если время вышло — возвращаем False
    
    Параметры:
    ─────────────────────────────────────────
    url : str
        URL для проверки (например, "http://backend:8080/api/health")
    timeout : int
        Максимальное время ожидания в секундах
    name : str
        Имя сервиса для логов (например, "Backend")
    
    Возвращает:
    ─────────────────────────────────────────
    bool
        True если сервис готов, False если таймаут истёк
    """
    # Запоминаем время начала
    # time.time() возвращает Unix timestamp (секунды с 1970 года)
    start = time.time()
    
    # Цикл while: пока не истёк таймаут
    # time.time() - start = сколько секунд прошло с начала
    while time.time() - start < timeout:
        try:
            # Пробуем сделать HTTP GET-запрос
            # timeout=2 — если сервер не ответит за 2 сек, бросится исключение
            resp = requests.get(url, timeout=2)
            
            # Проверяем HTTP-статус
            # 200 = OK, сервис работает
            if resp.status_code == 200:
                # Выводим сообщение об успехе
                print(f"✅ {name} готов: {url}")
                return True
                
        except requests.exceptions.RequestException:
            # Любая ошибка HTTP (нет соединения, таймаут, ошибка DNS, etc.)
            # Это нормально — сервис ещё запускается
            # Просто пробуем снова
            pass
        
        # Ждём 1 секунду перед следующей попыткой
        # Чтобы не долбить сервер запросами каждую миллисекунду
        time.sleep(1)
    
    # Если дошли сюда — время вышло, сервис не готов
    return False


# ═══════════════════════════════════════════════════════════════════════════════
# FIXTURE: ОЖИДАНИЕ ГОТОВНОСТИ СЕРВИСОВ
# ═══════════════════════════════════════════════════════════════════════════════

@pytest.fixture(scope="session", autouse=True)
def wait_for_services():
    """
    Ждёт готовности всех сервисов перед запуском тестов.
    
    Декораторы:
    ─────────────────────────────────────────
    @pytest.fixture — это fixture (подготовка для тестов)
    
    scope="session" — выполнить ОДИН РАЗ на всю сессию pytest
                      (не перед каждым тестом!)
    
    autouse=True — выполнить АВТОМАТИЧЕСКИ
                   Даже если тест не запрашивает эту fixture
                   (не нужно указывать параметр в тесте)
    
    Зачем это нужно:
    ─────────────────────────────────────────
    В Docker Compose контейнеры запускаются параллельно.
    
    Порядок событий:
    1. docker compose up запускает backend, frontend, tests
    2. backend начинает загружаться (JVM startup: 10-30 сек)
    3. tests уже запустился и пытается тестировать
    4. backend ещё не готов → тесты падают
    
    Эта fixture решает проблему:
    1. Перед ЛЮБЫМ тестом проверяем готовность сервисов
    2. Если не готовы — ждём
    3. Если таймаут — прерываем тесты с понятной ошибкой
    """
    # Красивый вывод в консоль
    print(f"\n⏳ Ожидание сервисов (до {STARTUP_WAIT} сек)...")
    
    # Список сервисов для проверки
    # Формат: (URL для проверки, Имя для логов)
    services = [
        # Backend проверяем через health endpoint
        (f"{BACKEND_URL}/api/health", "Backend"),
        # Frontend проверяем через главную страницу
        (FRONTEND_URL, "Frontend"),
    ]
    
    # Проверяем каждый сервис
    for url, name in services:
        if not wait_for_url(url, STARTUP_WAIT, name):
            # Сервис не готов за отведённое время
            # pytest.exit() немедленно прекращает ВСЕ тесты
            # с указанным сообщением об ошибке
            pytest.exit(f"❌ {name} не готов: {url}")
    
    # Все сервисы готовы!
    print("🚀 Все сервисы готовы!\n")


# ═══════════════════════════════════════════════════════════════════════════════
# FIXTURE: БРАУЗЕР ДЛЯ SELENIUM-ТЕСТОВ
# ═══════════════════════════════════════════════════════════════════════════════

@pytest.fixture(scope="function")
def browser():
    """
    Создаёт Selenium WebDriver для UI-тестов.
    
    Декораторы:
    ─────────────────────────────────────────
    scope="function" — создавать НОВЫЙ браузер для КАЖДОГО теста
    
    Почему для каждого теста?
    - Чистое состояние (нет cookies, localStorage от предыдущего теста)
    - Изоляция (ошибка в одном тесте не влияет на другие)
    - Надёжность (если браузер завис — следующий тест получит новый)
    
    Недостаток: медленнее, чем переиспользование браузера
    Для скорости можно использовать scope="module" или "session"
    
    yield vs return:
    ─────────────────────────────────────────
    Обычная функция:
        def foo():
            return value  # Функция завершается
    
    С yield:
        def foo():
            # Setup (до yield)
            yield value  # Функция "приостанавливается", value передаётся
            # Teardown (после yield) — выполняется после использования value
    
    В нашем случае:
    1. Код ДО yield: создание браузера (setup)
    2. yield driver: передача браузера в тест
    3. Тест выполняется с этим браузером
    4. Код ПОСЛЕ yield: закрытие браузера (teardown)
    
    Важно: teardown выполняется ВСЕГДА, даже если тест упал!
    Это гарантирует освобождение ресурсов.
    """
    
    # ═══════════════════════════════════════════════════════════════════════════
    # SETUP: Настройка и создание браузера
    # ═══════════════════════════════════════════════════════════════════════════
    
    # Создаём объект с настройками Chrome
    options = ChromeOptions()
    
    # ─────────────────────────────────────────────────────────────────────────
    # HEADLESS MODE (опционально)
    # ─────────────────────────────────────────────────────────────────────────
    #
    # HEADLESS=true  — браузер без GUI (для CI/CD)
    # HEADLESS=false — браузер с GUI (можно видеть через VNC/noVNC!)
    #
    # Когда использовать headless=false:
    # - Отладка тестов: видите что происходит в браузере
    # - Визуальное тестирование: открываете http://localhost:7900
    # - Демонстрация: показываете тесты клиенту/команде
    #
    # Когда использовать headless=true:
    # - CI/CD пайплайны (GitHub Actions, GitLab CI)
    # - Быстрые прогоны (меньше ресурсов)
    # - Серверы без GUI
    if HEADLESS:
        # --headless=new — запустить Chrome без графического интерфейса
        # =new — новый headless-режим Chrome (более стабильный)
        options.add_argument("--headless=new")
        print("🖥️  Режим: HEADLESS (без GUI)")
    else:
        # Видимый режим — можно смотреть через VNC/noVNC!
        # --start-maximized — открыть браузер на весь экран
        options.add_argument("--start-maximized")
        print("🎬 Режим: VISIBLE (смотрите на http://localhost:7900)")
    
    # ─────────────────────────────────────────────────────────────────────────
    # БЕЗОПАСНОСТЬ И DOCKER
    # ─────────────────────────────────────────────────────────────────────────
    #
    # --no-sandbox — отключить песочницу Chrome
    #
    # Sandbox (песочница) — это механизм изоляции процессов Chrome
    # для безопасности. Он требует определённых системных привилегий.
    #
    # В Docker эти привилегии часто недоступны, и Chrome не запускается.
    # --no-sandbox отключает эту защиту.
    #
    # ⚠️ В продакшене это менее безопасно, но для тестов — OK
    options.add_argument("--no-sandbox")
    
    # --disable-dev-shm-usage — не использовать /dev/shm
    #
    # /dev/shm — это shared memory (общая память) в Linux.
    # Chrome активно использует её для IPC (межпроцессное взаимодействие).
    #
    # В Docker /dev/shm по умолчанию имеет размер 64MB — этого мало для Chrome.
    # Без этого флага Chrome может падать с ошибкой "out of memory".
    #
    # Флаг говорит Chrome использовать /tmp вместо /dev/shm.
    options.add_argument("--disable-dev-shm-usage")
    
    # ─────────────────────────────────────────────────────────────────────────
    # РАЗМЕР ОКНА (для headless режима)
    # ─────────────────────────────────────────────────────────────────────────
    #
    # --window-size=1920,1080 — размер окна браузера в пикселях
    #
    # Даже в headless-режиме размер окна влияет на рендеринг страницы.
    # Responsive-вёрстка меняется в зависимости от ширины.
    #
    # 1920x1080 (Full HD) — стандартное разрешение десктопа.
    if HEADLESS:
        options.add_argument("--window-size=1920,1080")
    
    # ─────────────────────────────────────────────────────────────────────────
    # ПОДКЛЮЧЕНИЕ К SELENIUM
    # ─────────────────────────────────────────────────────────────────────────
    #
    # webdriver.Remote — создаёт WebDriver для удалённого браузера
    #
    # Почему "удалённый"?
    # Браузер Chrome запущен в ДРУГОМ контейнере (selenium-chrome).
    # Мы подключаемся к нему по сети через Selenium.
    #
    # SELENIUM_REMOTE_URL — для standalone-chrome с VNC
    # Формат: http://selenium-chrome:4444/wd/hub
    #
    # 🎬 С standalone-chrome вы можете:
    # - Открыть http://localhost:7900 в браузере
    # - Видеть Chrome в реальном времени
    # - Наблюдать как тесты кликают, вводят текст
    driver = webdriver.Remote(
        # URL Selenium (standalone-chrome или Hub)
        command_executor=SELENIUM_REMOTE_URL,
        # Настройки браузера
        options=options
    )
    
    # ─────────────────────────────────────────────────────────────────────────
    # IMPLICIT WAIT
    # ─────────────────────────────────────────────────────────────────────────
    #
    # implicitly_wait(10) — неявное ожидание до 10 секунд
    #
    # Когда Selenium ищет элемент (find_element), он может не найти его сразу:
    # - Страница ещё загружается
    # - JavaScript ещё не отрендерил элемент
    # - AJAX-запрос ещё не завершился
    #
    # С implicit wait:
    # - Если элемент не найден → Selenium ждёт до 10 сек
    # - Если элемент появился → продолжает немедленно
    # - Если 10 сек прошло и элемента нет → бросает исключение
    #
    # Это упрощает тесты: не нужно везде писать явные ожидания.
    driver.implicitly_wait(10)
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ПЕРЕДАЧА БРАУЗЕРА В ТЕСТ
    # ═══════════════════════════════════════════════════════════════════════════
    
    # yield передаёт driver в тест
    # Функция "приостанавливается" здесь, пока тест выполняется
    yield driver
    
    # ═══════════════════════════════════════════════════════════════════════════
    # TEARDOWN: Закрытие браузера
    # ═══════════════════════════════════════════════════════════════════════════
    
    # Этот код выполнится ПОСЛЕ теста (или после падения теста)
    
    # quit() закрывает браузер и освобождает ресурсы
    # Важно всегда закрывать браузер, иначе:
    # - Утечка памяти
    # - Занятые порты
    # - Selenium Grid будет считать сессию активной
    driver.quit()


# ═══════════════════════════════════════════════════════════════════════════════
# PYTEST-HTML: ДОБАВЛЕНИЕ DOCSTRINGS В ОТЧЁТ
# ═══════════════════════════════════════════════════════════════════════════════

@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    """
    Добавляет docstring теста в отчёт pytest-html.
    """
    outcome = yield
    report = outcome.get_result()
    
    # Добавляем docstring в extra для pytest-html
    if report.when == 'call':
        # Получаем docstring теста
        docstring = item.function.__doc__
        if docstring:
            # Берём первые 3 строки docstring (краткое описание)
            lines = [line.strip() for line in docstring.strip().split('\n') if line.strip()]
            description = '\n'.join(lines[:3])
            
            # Добавляем в extra для pytest-html
            extra = getattr(report, 'extra', [])
            extra.append(extras.html(f'<div class="description"><strong>Описание:</strong><br>{description}</div>'))
            report.extra = extra


def pytest_html_results_table_header(cells):
    """
    Добавляет колонку "Описание" в таблицу результатов HTML-отчёта.
    """
    cells.insert(2, '<th>Описание</th>')


def pytest_html_results_table_row(report, cells):
    """
    Добавляет описание теста (docstring) в строку таблицы HTML-отчёта.
    """
    # Извлекаем docstring из nodeid
    if hasattr(report, 'nodeid'):
        # Получаем краткое описание из первой строки docstring
        description = '—'
        
        # Пытаемся извлечь из extra
        if hasattr(report, 'extra') and report.extra:
            for extra in report.extra:
                if hasattr(extra, 'content') and 'Описание:' in str(extra.content):
                    # Извлекаем текст описания
                    import re
                    match = re.search(r'<strong>Описание:</strong><br>(.*?)</div>', str(extra.content))
                    if match:
                        description = match.group(1).replace('\n', '<br>')
                        break
        
        cells.insert(2, f'<td style="max-width: 300px; word-wrap: break-word;">{description}</td>')
    else:
        cells.insert(2, '<td>—</td>')
